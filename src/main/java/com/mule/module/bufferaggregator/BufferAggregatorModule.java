/**
* Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
* The software in this package is published under the terms of the CPAL v1.0
* license, a copy of which has been included with this distribution in the
* LICENSE.txt file.
**/

/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.mule.module.bufferaggregator;

import org.mule.api.MuleContext;
import org.mule.api.annotations.Category;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.annotations.param.Payload;
import org.mule.api.callback.SourceCallback;
import org.mule.api.store.ListableObjectStore;
import org.mule.api.store.ObjectDoesNotExistException;
import org.mule.api.store.ObjectStoreException;
import org.mule.api.store.ObjectStoreManager;
import org.mule.api.transaction.Transaction;
import org.mule.transaction.TransactionCoordination;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import java.io.Serializable;
import java.util.*;
import java.util.concurrent.locks.Lock;

/**
 * A module to implement the buffer pattern
 *
 * @author Simone Avossa
 */
@Module(friendlyName="Buffer Aggregator", name="bufferaggregator", schemaVersion="1.0.0-SNAPSHOT")
@Category(name = "org.mule.tooling.category.flowControl", description = "Flow Control")
public class BufferAggregatorModule
{
    public static final String BUFFER_GROUPS_STORE = "groups";

    private static Logger logger = LoggerFactory.getLogger(BufferAggregatorModule.class);

    /**
     * The maximum buffer size before being flushed
     */
    @Configurable
    private int bufferSize;

    /**
     * The time to live for the buffer before being flushed (milliseconds)
     */
    @Configurable
    private long bufferTimeToLive;

    /**
     * The object store prefix
     */
    @Configurable
    private String storePrefix;

    /**
     * Whether the messages in the buffer should be persisted (default is false)
     */
    @Configurable
    @Optional
    @Default("false")
    private boolean persistent;

    @Inject
    private ObjectStoreManager objectStoreManager;

    @Inject
    private MuleContext muleContext;

    private ListableObjectStore<Long> groups;

    public void setBufferSize(int bufferSize)
    {
        this.bufferSize = bufferSize;
    }

    public int getBufferSize()
    {
        return bufferSize;
    }

    public void setBufferTimeToLive(long bufferTimeToLive)
    {
        this.bufferTimeToLive = bufferTimeToLive;
    }

    public long getBufferTimeToLive()
    {
        return bufferTimeToLive;
    }

    public void setStorePrefix(String storePrefix)
    {
        this.storePrefix = storePrefix;
    }

    public String getStorePrefix()
    {
        return storePrefix;
    }

    public boolean isPersistent()
    {
        return persistent;
    }

    public void setPersistent(boolean persistent)
    {
        this.persistent = persistent;
    }

    public void setObjectStoreManager(ObjectStoreManager objectStoreManager)
    {
        this.objectStoreManager = objectStoreManager;
    }

    public ObjectStoreManager getObjectStoreManager()
    {
        return objectStoreManager;
    }

    public void setMuleContext(MuleContext muleContext)
    {
        this.muleContext = muleContext;
    }

    public MuleContext getMuleContext()
    {
        return muleContext;
    }

    @PostConstruct
    public void init()
    {
        groups = (ListableObjectStore<Long>) objectStoreManager.getObjectStore(storePrefix + "." + BUFFER_GROUPS_STORE, persistent);
    }

    /**
     * Buffer the payload of the incoming message
     *
     * {@sample.xml ../../../doc/BufferAggregator-connector.xml.sample bufferaggregator:buffer}
     *
     * @param group Identifies the group under which buffer the message
     * @param key Used to package messages together withing the same group
     */
    @Processor(intercepting = true)
    public void buffer(SourceCallback afterChain, String group, @Optional String key, @Payload Serializable payload) throws BufferException
    {
        Lock lock = muleContext.getLockFactory().createLock(group);
        lock.lock();

        String actualKey = null;
        ListableObjectStore<Serializable> buffer = null;

        try
        {
            synchronized (groups)
            {
                if (!groups.contains(group))
                {
                    groups.store(group, System.currentTimeMillis());
                }
            }

            if (key == null || key.equals(""))
            {
                actualKey = System.currentTimeMillis() + "-" + UUID.randomUUID().toString();
            }
            else
            {
                actualKey = key + "-" + System.currentTimeMillis() + "-" + UUID.randomUUID().toString();
            }

            buffer = (ListableObjectStore<Serializable>) objectStoreManager.getObjectStore(storePrefix + "." + group, persistent);
            buffer.store(actualKey, payload);

            List<Serializable> allKeys = buffer.allKeys();

            // Aggregate all the payloads and flush the buffer
            if (allKeys.size() >= bufferSize)
            {
                List<String> sortedKeys = sortKeys(allKeys);
                List<Serializable> aggregatedPayloads = aggregatePayloads(buffer, sortedKeys);

                if (!aggregatedPayloads.isEmpty())
                {
                    // Process aggregated payload
                    Map<String, Object> properties = new HashMap<String, Object>();
                    properties.put("group", group);
                    afterChain.process(aggregatedPayloads, properties);

                    // This is to ensure that the aggregated message is sent reliably in case the flow terminates unexpectedly.
                    Transaction tx = TransactionCoordination.getInstance().getTransaction();
                    if (!aggregatedPayloads.isEmpty() && tx != null && tx.isBegun())
                    {
                        tx.commit();
                    }
                }

                try
                {
                    // Clean the buffer
                    //cleanBuffer(buffer, sortedKeys);
                    cleanBuffer(buffer);
                }
                catch (Exception e)
                {
                    logger.error("Buffered messages were sent successfully, but it was not possible to clean the buffer for group '" + group + "' (this might cause some messages to be sent more than once)", e);
                }

                try
                {
                    groups.remove(group);
                }
                catch (ObjectDoesNotExistException e)
                {
                    // Do nothing as the key does not exist
                }
                catch (Exception e)
                {
                    logger.warn("Buffered messages were sent successfully, but it was not possible to remove the expired group '" + group + "' (this might cause the group to be flushed again)");

                    if (logger.isDebugEnabled())
                    {
                        logger.debug("Unable to remove group '" + group + "' from the object store", e);
                    }
                }
            }
        }
        catch (Exception e)
        {
            try
            {
                if (buffer != null && actualKey != null) {
                    buffer.remove(actualKey);
                }
            }
            catch (ObjectDoesNotExistException ex)
            {
                // Do nothing as the key does not exist
            }
            catch (Exception ex)
            {
                logger.error("Unable to remove the latest message from the object store, this will cause the messages to be sent more than once (group: " + group + ", key: " + actualKey + ")", e);
            }

            throw new BufferException("Unable to buffer message", e);
        }
        finally
        {
            lock.unlock();
        }
    }

    /**
     * Flushes the buffer
     *
     * {@sample.xml ../../../doc/BufferAggregator-connector.xml.sample bufferaggregator:flush-buffer}
     *
     */
    @Processor(intercepting = true)
    public void flushBuffer(SourceCallback afterChain) throws BufferException
    {
        try
        {
            List<Serializable> allKeys = groups.allKeys();

            for (int i = 0; i < allKeys.size(); i++)
            {
                long time = -1;
                try
                {
                    time = groups.retrieve(allKeys.get(i));
                }
                catch (ObjectDoesNotExistException e)
                {
                    // Do nothing as the key does not exist
                }

                // Aggregate all the payloads and flush the buffer
                if (time > -1 && (time + bufferTimeToLive < System.currentTimeMillis())) {
                    String group = (String) allKeys.get(i);

                    Lock lock = muleContext.getLockFactory().createLock(group);
                    lock.lock();

                    try
                    {
                        ListableObjectStore<Serializable> buffer = (ListableObjectStore<Serializable>) objectStoreManager.getObjectStore(storePrefix + "." + group, persistent);
                        List<Serializable> bufferAllKeys = buffer.allKeys();

                        List<String> sortedKeys = sortKeys(bufferAllKeys);
                        List<?> aggregatedPayloads = aggregatePayloads(buffer, sortedKeys);

                        if (!aggregatedPayloads.isEmpty())
                        {
                            // Process aggregated payload
                            Map<String, Object> properties = new HashMap<String, Object>();
                            properties.put("group", group);
                            afterChain.process(aggregatedPayloads, properties);

                            // This is to ensure that the aggregated message is sent reliably in case the flow terminates unexpectedly.
                            Transaction tx = TransactionCoordination.getInstance().getTransaction();
                            if (!aggregatedPayloads.isEmpty() && tx != null && tx.isBegun())
                            {
                                tx.commit();
                            }
                        }

                        try
                        {
                            // Clean the buffer
                            //cleanBuffer(buffer, sortedKeys);
                            cleanBuffer(buffer);
                        }
                        catch (Exception e)
                        {
                            logger.error("Buffered messages were sent successfully, but it was not possible to clean the buffer for group '" + group + "' (this might cause some messages to be sent more than once)", e);
                        }

                        try
                        {
                            groups.remove(group);
                        }
                        catch (ObjectDoesNotExistException e)
                        {
                            // Do nothing as the key does not exist
                        }
                        catch (Exception e)
                        {
                            logger.warn("Buffered messages were sent successfully, but it was not possible to remove the expired group '" + group + "' (this might cause the group to be flushed again)");

                            if (logger.isDebugEnabled())
                            {
                                logger.debug("Unable to remove group '" + group + "' from the object store", e);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        throw new BufferException("Unable to flush expired buffer for group: " + group, e);
                    }
                    finally
                    {
                        lock.unlock();
                    }
                }
            }
        }
        catch (Exception e)
        {
            throw new BufferException("Unable to flush expired buffer", e);
        }
    }

    private List<Serializable> aggregatePayloads(ListableObjectStore<Serializable> buffer, List<String> keys) throws ObjectStoreException
    {
        List<Serializable> aggregatedPayloads = new ArrayList<Serializable>();
        for (int i = 0; i < keys.size(); i++)
        {
            try
            {
                Serializable value = (Serializable) buffer.retrieve(keys.get(i));
                aggregatedPayloads.add(value);
            }
            catch (ObjectDoesNotExistException e)
            {
                // Do nothing as the key does not exist
            }
        }

        return aggregatedPayloads;
    }

    private void cleanBuffer(ListableObjectStore<Serializable> buffer) throws ObjectStoreException
    {
        objectStoreManager.disposeStore(buffer);
    }

    private void cleanBuffer(ListableObjectStore<Serializable> buffer, List<String> keys) throws ObjectStoreException
    {
        for (int i = 0; i < keys.size(); i++)
        {
            try
            {
                buffer.remove(keys.get(i));
            }
            catch (ObjectDoesNotExistException e)
            {
                // Do nothing as the key does not exist
            }
        }
    }

    private List<String> sortKeys(List<Serializable> keys)
    {
        List<String> sortedKeys= new ArrayList<String>();
        for (int i = 0; i < keys.size(); i++)
        {
            sortedKeys.add((String) keys.get(i));
        }

        Collections.sort(sortedKeys);

        return sortedKeys;
    }
}
